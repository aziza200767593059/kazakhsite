// data.js - База данных вопросов и AI ответов

// Database of questions
const questionsDB = {
    programming: {
        variables: {
            easy: [
                { q: "Python-да айнымалыны қалай жариялайсыз? Мысал келтіріңіз.", a: "x = 10" },
                { q: "String және integer арасындағы айырмашылық неде?", a: "String - мәтін, integer - бүтін сан" },
                { q: "Python-да тұрақты (constant) қалай жасалады?", a: "Үлкен әріппен жазу келісілген, мысалы PI = 3.14" },
                { q: "Айнымалының атауы санмен басталуы мүмкін бе?", a: "Жоқ, айнымалы әріппен немесе астын сызумен басталуы керек" },
                { q: "int(\"123\") нәтижесі не болады?", a: "123 бүтін санына түрлендіріледі" },
                { q: "type(5.5) командасы не қайтарады?", a: "float типін қайтарады" },
                { q: "None мәні Python-да не үшін қолданылады?", a: "Ешқандай мән жоқ екенін көрсету үшін" },
                { q: "Boolean типінде қандай мәндер бар?", a: "True және False" },
                { q: "Python-да комментарий қалай жазылады?", a: "# символымен басталады" },
                { q: "input() функциясы не істейді?", a: "Пайдаланушыдан мәтін енгізуді сұрайды" }
            ],
            medium: [
                { q: "List және tuple арасындағы негізгі айырмашылық неде?", a: "List өзгертілетін, tuple өзгертілмейтін" },
                { q: "Dictionary деген не және оның негізгі ерекшелігі қандай?", a: "Кілт-мән жұптарын сақтайтын деректер құрылымы" },
                { q: "List comprehension қалай жұмыс істейді? Мысал келтіріңіз.", a: "[x*2 for x in range(5)]" },
                { q: "Global және local айнымалылар арасындағы айырмашылық неде?", a: "Global - бүкіл бағдарламада, local - функция ішінде ғана" },
                { q: "Mutable және immutable типтер дегеніміз не? Мысалдар келтіріңіз.", a: "Mutable өзгереді (list), immutable өзгермейді (tuple)" },
                { q: "enumerate() функциясы не үшін қолданылады?", a: "Элементтер мен индекстерді бір мезгілде алу үшін" },
                { q: "zip() функциясы қалай жұмыс істейді?", a: "Бірнеше тізімдерді параллель біріктіреді" },
                { q: "Lambda функциясы қашан пайдалы?", a: "Қысқа, бір реттік функциялар үшін" },
                { q: "*args және **kwargs не үшін қолданылады?", a: "Айнымалы санда аргументтер үшін" },
                { q: "List slicing синтаксисі қалай жұмыс істейді?", a: "list[start:end:step] форматында" }
            ],
            hard: [
                { q: "Декораторлар Python-да қалай жұмыс істейді? Өз декораторыңызды жасаңыз.", a: "Функцияны басқа функцияға орайтын функция" },
                { q: "Generator және iterator арасындағы айырмашылық неде?", a: "Generator мәндерді қажет кезінде генерациялайды" },
                { q: "Context manager (__enter__ және __exit__) қалай жұмыс істейді?", a: "Ресурстарды басқару үшін with операторымен қолданылады" },
                { q: "Метаклассы не үшін қолданылады?", a: "Класстардың өздерін құру және өзгерту үшін" },
                { q: "GIL (Global Interpreter Lock) дегеніміз не және ол қалай әсер етеді?", a: "Python-да тек бір thread кодты орындай алады" },
                { q: "Дескрипторлар Python-да қалай жұмыс істейді?", a: "__get__, __set__, __delete__ арқылы атрибутқа қатынасуды басқару" },
                { q: "Memory management Python-да қалай жұмыс істейді?", a: "Reference counting және garbage collection" },
                { q: "Async/await синтаксисі қалай жұмыс істейді?", a: "Асинхронды операцияларды бір уақытта орындау үшін" },
                { q: "Type hints мен annotations не үшін қолданылады?", a: "Код түсініктілігі мен статикалық тексеру үшін" },
                { q: "Monkey patching дегеніміз не және оның қауіптері қандай?", a: "Runtime кезінде класс немесе модульді өзгерту" }
            ]
        },
        loops: {
            easy: [
                { q: "for циклы қалай жұмыс істейді? Мысал келтіріңіз.", a: "for i in range(5): print(i)" },
                { q: "while циклы қашан қолданылады?", a: "Шарт орындалғанша қайталау үшін" },
                { q: "range(10) не қайтарады?", a: "0-ден 9-ға дейінгі сандар тізімі" },
                { q: "break операторы не істейді?", a: "Циклды тоқтатады" },
                { q: "continue операторы не істейді?", a: "Келесі итерацияға өтеді" },
                { q: "Циклді 1-ден 10-ға дейін санау үшін қалай жазасыз?", a: "for i in range(1, 11)" },
                { q: "Тізімнің элементтері бойынша қалай итерация жасайсыз?", a: "for item in list:" },
                { q: "else блогы циклмен бірге қалай жұмыс істейді?", a: "Цикл break арқылы үзілмесе орындалады" },
                { q: "Шексіз циклды қалай жасайсыз?", a: "while True:" },
                { q: "range(0, 10, 2) не береді?", a: "0, 2, 4, 6, 8 - жұп сандар" }
            ],
            medium: [
                { q: "Nested loops дегеніміз не? Мысал келтіріңіз.", a: "Цикл ішінде цикл, мысалы матрицаны өңдеу үшін" },
                { q: "List comprehension мен әдеттегі цикл арасындағы айырмашылық неде?", a: "Comprehension тезірек және қысқа" },
                { q: "enumerate() циклда қалай қолданылады?", a: "for i, value in enumerate(list):" },
                { q: "reversed() функциясы қалай жұмысістейді?", a: "Тізімді кері бағытта итерациялау үшін" },
                { q: "Цикл ішінде қате болса, қалай өңдейсіз?", a: "try-except блогын қолдану" },
                { q: "while True циклін қауіпсіз қалай тоқтатуға болады?", a: "Белгілі бір шартта break қолдану" },
                { q: "Dictionary бойынша итерация жасау үшін қандай әдістер бар?", a: ".items(), .keys(), .values()" },
                { q: "Циклдың өнімділігін қалай арттыруға болады?", a: "Generator expression, map(), filter() қолдану" },
                { q: "itertools модулі не береді?", a: "Тиімді итераторлар жасау құралдарын" },
                { q: "Бір циклда бірнеше тізімді параллель өңдеу үшін не қолданылады?", a: "zip() функциясы" }
            ],
            hard: [
                { q: "Generator expression мен list comprehension арасындағы өнімділік айырмашылығы неде?", a: "Generator жадты тиімді пайдаланады, мәндерді қажет кезде генерациялайды" },
                { q: "Itertools.product() функциясы қалай жұмыс істейді?", a: "Декарт көбейтіндісін жасайды" },
                { q: "Рекурсия мен итерация арасындағы айырмашылық және қашан қайсысын қолдану керек?", a: "Рекурсия элегантты, бірақ жады көбірек, итерация тиімді" },
                { q: "Tail recursion optimization Python-да бар ма?", a: "Жоқ, Python tail recursion optimize етпейді" },
                { q: "Корутиндер (coroutines) мен циклдар қалай біріктіріледі?", a: "async for арқылы асинхронды итерацияда" },
                { q: "Itertools.cycle() қашан пайдалы және қандай қауіптер бар?", a: "Тізімді шексіз қайталау үшін, жады проблемасы болуы мүмкін" },
                { q: "Custom iterator класы қалай жасалады?", a: "__iter__() және __next__() әдістерін анықтау" },
                { q: "Циклдың уақыттық күрделілігін қалай есептейсіз?", a: "O(n) - бір цикл, O(n²) - екі кірістірілген цикл" },
                { q: "Мемоизация циклдарда қалай қолданылады?", a: "Есептелген мәндерді кэштеу арқылы қайталауды болдырмау" },
                { q: "Python-да циклдарды параллельдеу үшін қандай әдістер бар?", a: "multiprocessing, concurrent.futures, asyncio" }
            ]
        },
        functions: {
            easy: [
                { q: "Функция қалай анықталады?", a: "def function_name(): арқылы" },
                { q: "return операторы не істейді?", a: "Функциядан мән қайтарады" },
                { q: "Параметр және аргумент арасындағы айырмашылық неде?", a: "Параметр - анықтамада, аргумент - шақыруда" },
                { q: "Default параметр мәні қалай беріледі?", a: "def func(x=10): форматында" },
                { q: "Функция бірнеше мән қайтара ала ма?", a: "Иә, tuple ретінде: return x, y" },
                { q: "pass операторы не үшін қолданылады?", a: "Бос функция немесе класс үшін" },
                { q: "Докстринг (docstring) дегеніміз не?", a: "Функцияның сипаттамасы үш қосарнышаның ішінде" },
                { q: "Функцияны қалай шақырасыз?", a: "function_name() деп жазу арқылы" },
                { q: "Рекурсивті функция дегеніміз не?", a: "Өзін-өзі шақыратын функция" },
                { q: "print() және return арасындағы айырмашылық неде?", a: "print экранға шығарады, return мән қайтарады" }
            ],
            medium: [
                { q: "Keyword arguments дегеніміз не?", a: "func(name='Alice', age=25) форматындағы аргументтер" },
                { q: "Функцияның scope дегеніміз не?", a: "Айнымалылардың көрінетін аймағы" },
                { q: "Closure дегеніміз не?", a: "Сыртқы функцияның айнымалыларын есте сақтайтын функция" },
                { q: "First-class function дегеніміз не?", a: "Функцияларды айнымалыға тағайындауға болады" },
                { q: "Higher-order function дегеніміз не?", a: "Басқа функцияны қабылдайтын немесе қайтаратын функция" },
                { q: "map() функциясы қалай жұмыс істейді?", a: "Функцияны әрбір элементке қолданады" },
                { q: "filter() функциясы не істейді?", a: "Шартты қанағаттандыратын элементтерді сүзеді" },
                { q: "reduce() функциясы қалай жұмыс істейді?", a: "Элементтерді бір мәнге жинақтайды" },
                { q: "Partial functions дегеніміз не?", a: "Кейбір параметрлері алдын ала берілген функция" },
                { q: "Function annotations не үшін қолданылады?", a: "Типтерді көрсету үшін: def func(x: int) -> str:" }
            ],
            hard: [
                { q: "Декораторлар қалай жұмыс істейді?", a: "Функцияны модификациялайтын wrapper функция" },
                { q: "Generator функциясы дегеніміз не?", a: "yield қолданатын, мәндерді біртіндеп қайтаратын функция" },
                { q: "Currying дегеніміз не?", a: "Көп параметрлі функцияны бір параметрлі функциялар тізбегіне түрлендіру" },
                { q: "Мемоизация қалай жүзеге асырылады?", a: "Нәтижелерді кэштеу арқылы қайталанатын есептеулерді болдырмау" },
                { q: "Tail call optimization дегеніміз не?", a: "Рекурсияны циклге айналдыру (Python-да жоқ)" },
                { q: "Async функциялар қалай жұмыс істейді?", a: "async def арқылы, await операторымен асинхронды орындау" },
                { q: "Contextlib модулі не береді?", a: "Context manager жасау құралдары: @contextmanager" },
                { q: "Functools модуліндегі lru_cache не істейді?", a: "Функция нәтижелерін автоматты кэштейді" },
                { q: "Multiple dispatch дегеніміз не?", a: "Аргументтердің типіне қарай функция таңдау" },
                { q: "Introspection функцияларда қалай қолданылады?", a: "inspect модулі арқылы функция метаданын алу" }
            ]
        }
    },
    algorithms: {
        sorting: {
            easy: [
                { q: "Bubble sort алгоритмі қалай жұмыс істейді?", a: "Көрші элементтерді салыстырып, үлкенді соңына жылжытады" },
                { q: "Selection sort дегеніміз не?", a: "Ең кішісін таңдап, басына қояды" },
                { q: "Сұрыптаудың уақыттық күрделілігі деген не?", a: "Алгоритмнің орындалу уақытын өлшейді" },
                { q: "O(n²) күрделілік дегеніміз не?", a: "Екі кірістірілген цикл, квадраттық өсу" },
                { q: "In-place sorting дегеніміз не?", a: "Қосымша жады қолданбай сұрыптау" },
                { q: "Stable sorting дегеніміз не?", a: "Тең элементтердің реті сақталады" },
                { q: "Python-да тізімді қалай сұрыптайсыз?", a: "list.sort() немесе sorted(list)" },
                { q: "sorted() мен .sort() арасындағы айырмашылық неде?", a: "sorted() жаңа тізім қайтарады, sort() орнында өзгертеді" },
                { q: "Тізімді кері ретпен сұрыптау үшін не істейсіз?", a: "reverse=True параметрін қолдану" },
                { q: "Key parameter сұрыптауда не істейді?", a: "Элементтерді салыстыру критерийін анықтайды" }
            ],
            medium: [
                { q: "Quick sort алгоритмінің негізгі идеясы қандай?", a: "Pivot таңдап, кіші және үлкен элементтерге бөлу" },
                { q: "Merge sort қалай жұмыс істейді?", a: "Бөліп, сұрыптап, біріктіру (divide and conquer)" },
                { q: "Quick sort-тың worst case күрделілігі қашан болады?", a: "Pivot нашар таңдалса O(n²)" },
                { q: "Merge sort-тың артықшылықтары мен кемшіліктері қандай?", a: "Тұрақты O(n log n), бірақ қосымша жады керек" },
                { q: "Insertion sort қашан тиімді?", a: "Кіші немесе дерлік сұрыпталған массивтерде" },
                { q: "Heap sort дегеніміз не?", a: "Binary heap құрып, max/min элементтерді алу арқылы сұрыптау" },
                { q: "Counting sort қалай жұмыс істейді?", a: "Элементтердің санын есептеп, орналастыру" },
                { q: "Radix sort қашан пайдалы?", a: "Бүтін сандарды разрядтар бойынша сұрыптауда" },
                { q: "Bucket sort дегеніміз не?", a: "Элементтерді basket-терге бөліп, әрқайсысын сұрыптау" },
                { q: "Сұрыптау алгоритмін қалай таңдайсыз?", a: "Деректер мөлшері, типі және жады шектеулері бойынша" }
            ],
            hard: [
                { q: "Quick sort-ты оптимизациялаудың қандай әдістері бар?", a: "Median-of-three pivot, tail recursion, hybrid with insertion sort" },
                { q: "External sorting дегеніміз не және қашан қолданылады?", a: "Үлкен деректерді дискте сұрыптау, жады жетпеген жағдайда" },
                { q: "Timsort алгоритмі қалай жұмыс істейді?", a: "Merge sort пен insertion sort гибриді, Python-да қолданылады" },
                { q: "Lower bound of comparison-based sorting дегеніміз не?", a: "Ω(n log n) - салыстыру арқылы сұрыптаудың минималды күрделілігі" },
                { q: "Cache-efficient sorting алгоритмдері қалай жасалады?", a: "Locality of reference принципін қолдану" },
                { q: "Parallel sorting алгоритмдері қалай жұмыс істейді?", a: "Деректерді бөліп, бір мезгілде өңдеу" },
                { q: "Adaptive sorting дегеніміз не?", a: "Деректердің қазіргі ретіне қарай тиімділігін арттыру" },
                { q: "Introsort алгоритмі не үшін жасалған?", a: "Quick sort-тың worst case жағдайын болдырмау үшін" },
                { q: "Sorting network дегеніміз не?", a: "Салыстырулардың фиксті тізбегі, параллельденеді" },
                { q: "String sorting-тың ерекшеліктері қандай?", a: "Radix sort вариациялары, prefix-тер бойынша оптимизация" }
            ]
        },
        search: {
            easy: [
                { q: "Linear search қалай жұмыс істейді?", a: "Элементтерді бір-бірлеп тексеру" },
                { q: "Binary search үшін қандай шарт қажет?", a: "Массив сұрыпталған болуы керек" },
                { q: "Binary search-тың уақыттық күрделілігі қандай?", a: "O(log n)" },
                { q: "Linear search-тың worst case күрделілігі қандай?", a: "O(n) - барлық элементтерді тексеру керек" },
                { q: "Python-да элементті тізімде қалай іздейсіз?", a: "item in list немесе list.index(item)" },
                { q: "Binary search рекурсия арқылы жазылуы мүмкін бе?", a: "Иә, екі түрде де (итеративті және рекурсивті) жазуға болады" },
                { q: "Элемент табылмаса, binary search не қайтарады?", a: "Әдетте -1 немесе None" },
                { q: "Сұрыпталмаған тізімде binary search жұмыс істейді ме?", a: "Жоқ, алдымен сұрыптау керек" },
                { q: "Іздеу алгоритмін қалай таңдайсыз?", a: "Деректер сұрыпталған ба, мөлшері қандай деген сұрақтарға жауап беру керек" },
                { q: "Python-дағы 'in' оператор қалай жұмыс істейді?", a: "Linear search жасайды, O(n) күрделілік" }
            ],
            medium: [
                { q: "Jump search алгоритмі қалай жұмыс істейді?", a: "Блоктармен секіріп, содан кейін linear search" },
                { q: "Interpolation search дегеніміз не?", a: "Мәннің орналасуын бағалап іздейді" },
                { q: "Exponential search қалай жұмыс істейді?", a: "Экспоненциалды өсіріп, binary search қолданады" },
                { q: "Hash table-да іздеу қалай жұмыс істейді?", a: "Hash функция арқылы O(1) күрделілікте" },
                { q: "Ternary search дегеніміз не?", a: "Үш бөлікке бөліп іздеу, unimodal функцияларда" },
                { q: "Fibonacci search қалай жұмыс істейді?", a: "Fibonacci сандарын қолданып бөлу" },
                { q: "Substring search (pattern matching) қалай жұмыс істейді?", a: "Мәтінде ішкі жолды іздеу" },
                { q: "KMP алгоритмі не үшін қолданылады?", a: "Тиімді substring search үшін" },
                { q: "Boyer-Moore алгоритмінің артықшылығы қандай?", a: "Pattern-ді оңнан солға салыстырып, секірулер жасайды" },
                { q: "Rabin-Karp алгоритмі қалай жұмыс істейді?", a: "Hash мәндерін салыстыру арқылы" }
            ],
            hard: [
                { q: "Self-balancing binary search tree дегеніміз не?", a: "AVL, Red-Black trees - O(log n) іздеу кепілдігімен" },
                { q: "B-tree мен binary search tree арасындағы айырмашылық неде?", a: "B-tree бір node-та көп кілттер сақтайды, дискте тиімді" },
                { q: "Trie (prefix tree) қалай жұмыс істейді?", a: "Әріптер бойынша ағаш, жолдарды іздеуде тиімді" },
                { q: "Suffix array мен suffix tree арасындағы айырмашылық неде?", a: "Array жадты аз пайдаланады, tree тезірек" },
                { q: "Bloom filter дегеніміз не және қашан пайдалы?", a: "Probabilistic data structure, элемент жоқ екенін анықтау үшін" },
                { q: "Skip list қалай жұмыс істейді?", a: "Көп деңгейлі linked list, O(log n) іздеу" },
                { q: "Van Emde Boas tree дегеніміз не?", a: "O(log log n) operations, бүтін кілттер үшін" },
                { q: "Aho-Corasick алгоритмі не істейді?", a: "Бір мезгілде бірнеше pattern іздейді" },
                { q: "Locality-sensitive hashing дегеніміз не?", a: "Ұқсас элементтерді табу үшін hash" },
                { q: "Quantum search (Grover's algorithm) классикалық іздеуден қалай ерекшеленеді?", a: "O(√n) күрделілік, сұрыпталмаған деректерде" }
            ]
        },
        graphs: {
            easy: [
                { q: "Граф дегеніміз не?", a: "Түйіндер (vertices) және қырлар (edges) жиынтығы" },
                { q: "Directed және undirected графтар арасындағы айырмашылық неде?", a: "Directed - бағыттары бар, undirected - жоқ" },
                { q: "Weighted граф дегеніміз не?", a: "Қырларға салмақтар тағайындалған граф" },
                { q: "Adjacency matrix дегеніміз не?", a: "Графты 2D массивпен көрсету" },
                { q: "Adjacency list дегеніміз не?", a: "Әрбір түйін үшін көршілер тізімі" },
                { q: "Degree of vertex дегеніміз не?", a: "Түйінге жалғанған қырлар саны" },
                { q: "Path дегеніміз не?", a: "Түйіндер тізбегі қырлармен байланысқан" },
                { q: "Cycle дегеніміз не?", a: "Басы мен соңы бірдей жол" },
                { q: "Connected граф дегеніміз не?", a: "Барлық түйіндер арасында жол бар граф" },
                { q: "Tree дегеніміз не?", a: "Циклсіз, байланысты граф" }
            ],
            medium: [
                { q: "DFS (Depth-First Search) қалай жұмыс істейді?", a: "Тереңдікке дейін зерттеу, stack қолдану" },
                { q: "BFS (Breadth-First Search) қалай жұмыс істейді?", a: "Кеңдікке қарай зерттеу, queue қолдану" },
                { q: "Dijkstra алгоритмі не істейді?", a: "Ең қысқа жолды табады (оң салмақтарда)" },
                { q: "Bellman-Ford алгоритмі қашан пайдалы?", a: "Теріс салмақтар болғанда да жұмыс істейді" },
                { q: "Topological sort дегеніміз не?", a: "DAG түйіндерін сызықты реттеу" },
                { q: "Spanning tree дегеніміз не?", a: "Барлық түйіндерді байланыстыратын циклсіз ағаш" },
                { q: "Prim's алгоритмі не істейді?", a: "Minimum spanning tree табады" },
                { q: "Kruskal's алгоритмі қалай жұмыс істейді?", a: "Қырларды салмақ бойынша сұрыптап, MST құрайды" },
                { q: "Bipartite граф дегеніміз не?", a: "Түйіндерді екі топқа бөлуге болатын граф" },
                { q: "Strongly connected component дегеніміз не?", a: "Әрбір түйіннен әрбір түйінге жол бар бөлік" }
            ],
            hard: [
                { q: "Floyd-Warshall алгоритмі қалай жұмыс істейді?", a: "Барлық жұп түйіндер арасындағы ең қысқа жолды табады, O(n³)" },
                { q: "A* алгоритмі Dijkstra-дан қалай ерекшеленеді?", a: "Heuristic қолданады, мақсатқа тезірек жетеді" },
                { q: "Network flow алгоритмдері не үшін?", a: "Максималды ағын есептеу (Ford-Fulkerson, Dinic)" },
                { q: "Tarjan's алгоритмі не істейді?", a: "Strongly connected components табады, O(V+E)" },
                { q: "Graph coloring problem дегеніміз не?", a: "Түйіндерді көршілері әртүрлі болатындай түске бояу" },
                { q: "Hamiltonian path және Eulerian path арасындағы айырмашылық неде?", a: "Hamiltonian - әрбір түйін бір рет, Eulerian - әрбір қыр бір рет" },
                { q: "Minimum cut problem дегеніміз не?", a: "Графты екі бөлікке бөлетін минималды қырлар жиынтығы" },
                { q: "Traveling Salesman Problem қалай шешіледі?", a: "NP-hard, dynamic programming немесе approximation алгоритмдер" },
                { q: "Graph isomorphism problem дегеніміз не?", a: "Екі графтың құрылымдық бірдей екенін анықтау" },
                { q: "PageRank алгоритмі қалай жұмыс істейді?", a: "Граф түйіндерінің маңыздылығын есептейді (Google search)" }
            ]
        }
    },
    databases: {
        sql: {
            easy: [
                { q: "SELECT операторы не істейді?", a: "Деректер қорынан деректерді оқиды" },
                { q: "WHERE clause не үшін қолданылады?", a: "Деректерді сүзу үшін" },
                { q: "INSERT операторы қалай жұмыс істейді?", a: "Кесте жаңа жол қосады" },
                { q: "UPDATE операторы не істейді?", a: "Бар деректерді жаңартады" },
                { q: "DELETE операторы қалай жұмыс істейді?", a: "Кестеден жолдарды өшіреді" },
                { q: "Primary key дегеніміз не?", a: "Әрбір жолды бірегей анықтайтын бағана" },
                { q: "Foreign key не үшін қолданылады?", a: "Кестелер арасында байланыс орнату үшін" },
                { q: "CREATE TABLE синтаксисі қалай?", a: "CREATE TABLE table_name (column1 type, column2 type)" },
                { q: "DROP TABLE не істейді?", a: "Кестені толығымен өшіреді" },
                { q: "ORDER BY не үшін қолданылады?", a: "Нәтижелерді сұрыптау үшін" }
            ],
            medium: [
                { q: "JOIN түрлері қандай және олардың айырмашылықтары неде?", a: "INNER, LEFT, RIGHT, FULL - кестелерді біріктіру әдістері" },
                { q: "GROUP BY не істейді?", a: "Жолдарды топтастырып, агрегат функциялар қолданады" },
                { q: "HAVING мен WHERE арасындағы айырмашылық неде?", a: "HAVING GROUP BY-дан кейін, WHERE бұрын қолданылады" },
                { q: "Aggregate functions деген не? Мысалдар келтіріңіз.", a: "COUNT, SUM, AVG, MIN, MAX - есептеу функциялары" },
                { q: "Index дегеніміз не және ол не береді?", a: "Іздеуді жылдамдататын деректер құрылымы" },
                { q: "UNION оператор не істейді?", a: "Екі SELECT нәтижесін біріктіреді" },
                { q: "Subquery дегеніміз не?", a: "Сұраныс ішінде орналасқан сұраныс" },
                { q: "VIEW дегеніміз не?", a: "Виртуальды кесте, сұраныстың сақталған нәтижесі" },
                { q: "Transaction дегеніміз не?", a: "Бір бүтін операция ретінде орындалатын әрекеттер тобы" },
                { q: "ACID қасиеттері не?", a: "Atomicity, Consistency, Isolation, Durability" }
            ],
            hard: [
                { q: "Query optimization қалай жұмыс істейді?", a: "Execution plan талдау, индекстер, статистика" },
                { q: "Normalization дегеніміз не және неше формасы бар?", a: "Деректерді ұйымдастыру, қайталауды азайту, 1NF-5NF" },
                { q: "Denormalization қашан қажет?", a: "Оқу өнімділігін арттыру үшін" },
                { q: "Window functions қалай жұмыс істейді?", a: "ROW_NUMBER, RANK, LEAD, LAG - жолдар терезесінде есептеу" },
                { q: "CTE (Common Table Expression) не үшін пайдалы?", a: "Күрделі сұраныстарды оқуға оңай етеді, рекурсия үшін" },
                { q: "Stored procedures мен functions арасындағы айырмашылық неде?", a: "Procedure мән қайтармайды, transaction бар, function мән қайтарады" },
                { q: "Triggers қалай жұмыс істейді және қашан пайдалы?", a: "Автоматты әрекеттер INSERT/UPDATE/DELETE кезінде" },
                { q: "Database sharding дегеніміз не?", a: "Деректерді бірнеше серверлерге горизонтальды бөлу" },
                { q: "Replication түрлері қандай?", a: "Master-Slave, Master-Master, Multi-Master" },
                { q: "CAP theorem дегеніміз не?", a: "Consistency, Availability, Partition tolerance - үшеуін бірдей алу мүмкін емес" }
            ]
        },
        nosql: {
            easy: [
                { q: "NoSQL деректер қоры SQL-ден қалай ерекшеленеді?", a: "Схема жоқ, горизонтальды масштабтау, әртүрлі деректер модельдері" },
                { q: "Document database дегеніміз не?", a: "JSON-тәрізді құжаттарды сақтайды (MongoDB)" },
                { q: "Key-value store дегеніміз не?", a: "Қарапайым кілт-мән жұптары (Redis)" },
                { q: "MongoDB-де құжат қалай сақталады?", a: "BSON форматында (Binary JSON)" },
                { q: "MongoDB-де жазба қалай қосылады?", a: "insertOne() немесе insertMany()" },
                { q: "MongoDB-де деректерді қалай табасыз?", a: "find() немесе findOne()" },
                { q: "Redis не үшін қолданылады?", a: "Кэш, сессиялар, жылдам деректер сақтау" },
                { q: "Collection дегеніміз не MongoDB-де?", a: "SQL кестесіне ұқсас, құжаттар тобы" },
                { q: "MongoDB-дегі _id өрісі не?", a: "Әрбір құжаттың бірегей идентификаторы" },
                { q: "NoSQL қашан SQL-ден артық?", a: "Үлкен көлем, жылдам өсу, икемді схема керек болғанда" }
            ],
            medium: [
                { q: "MongoDB-де aggregation pipeline қалай жұмыс істейді?", a: "Деректерді өңдеу кезеңдері: $match, $group, $project" },
                { q: "MongoDB-де index түрлері қандай?", a: "Single field, compound, text, geospatial" },
                { q: "Embedding vs referencing MongoDB-де - қашан қайсысын қолдану керек?", a: "Embedding - көп оқылатын, referencing - көп өзгертілетін" },
                { q: "Redis-те деректер түрлері қандай?", a: "String, List, Set, Sorted Set, Hash" },
                { q: "Column-family stores дегеніміз не?", a: "Cassandra, HBase - бағандар бойынша сақтау" },
                { q: "Graph database қашан пайдалы?", a: "Күрделі қатынастарды модельдеуде (Neo4j)" },
                { q: "MongoDB-де replica set дегеніміз не?", a: "Деректердің көшірмелері бірнеше серверде" },
                { q: "Eventual consistency дегеніміз не?", a: "Деректер уақыт өте келе синхрондалады" },
                { q: "Time series database дегеніміз не?", a: "Уақыт белгілері бар деректерге оптималданған (InfluxDB)" },
                { q: "MongoDB-де sharding қалай жұмыс істейді?", a: "Деректерді shard key бойынша бөлу" }
            ],
            hard: [
                { q: "MongoDB-дегі WiredTiger storage engine қалай жұмыс істейді?", a: "Document-level locking, compression, checksums" },
                { q: "Redis cluster архитектурасы қандай?", a: "Hash slots (16384), automatic sharding" },
                { q: "Cassandra-ның consistency levels қандай?", a: "ONE, QUORUM, ALL - оқу/жазу кепілдіктері" },
                { q: "MongoDB-де change streams не үшін қолданылады?", a: "Real-time деректер өзгерістерін тыңдау" },
                { q: "Redis Sentinel дегеніміз не?", a: "High availability үшін monitoring және failover" },
                { q: "MongoDB transactions қалай жұмыс істейді?", a: "Multi-document ACID transactions replica set-терде" },
                { q: "Cassandra-ның write path архитектурасы қандай?", a: "Memtable → SSTable → Compaction" },
                { q: "Neo4j-дегі Cypher тілі не істейді?", a: "Graph қатынастарын сұрау тілі" },
                { q: "MongoDB-де geospatial queries қалай жұмыс істейді?", a: "2d және 2dsphere индекстері, $near операторы" },
                { q: "Polyglot persistence дегеніміз не?", a: "Әртүрлі деректер қорларын бір жүйеде қолдану" }
            ]
        },
        optimization: {
            easy: [
                { q: "Index не үшін керек?", a: "Іздеуді жылдамдату үшін" },
                { q: "Query cache дегеніміз не?", a: "Сұраныс нәтижелерін сақтау" },
                { q: "EXPLAIN команд асы не істейді?", a: "Сұраныс орындалу жоспарын көрсетеді" },
                { q: "Full table scan дегеніміз не?", a: "Кестенің барлық жолдарын оқу (баяу)" },
                { q: "Index scan дегеніміз не?", a: "Индекс арқылы жылдам іздеу" },
                { q: "Composite index дегеніміз не?", a: "Бірнеше бағанаға индекс" },
                { q: "Unique index не береді?", a: "Қайталанбас мәндерді кепілдендіреді" },
                { q: "Query optimization дегеніміз не?", a: "Сұранысты тезірек орындау әдістері" },
                { q: "Covering index дегеніміз не?", a: "Барлық қажетті бағандары бар индекс" },
                { q: "Cardinality дегеніміз не?", a: "Бірегей мәндер саны" }
            ],
            medium: [
                { q: "B-tree index қалай жұмыс істейді?", a: "Сұрыпталған ағаш құрылымы, O(log n) іздеу" },
                { q: "Hash index қашан пайдалы?", a: "Тең салыстырулар үшін (=), O(1) күрделілік" },
                { q: "Bitmap index дегеніміз не?", a: "Төмен cardinality бағандар үшін тиімді" },
                { q: "Query rewrite дегеніміз не?", a: "Сұранысты оптимальды формаға түрлендіру" },
                { q: "Partition pruning дегеніміз не?", a: "Қажет емес partition-дарды өткізіп жіберу" },
                { q: "Index merge дегеніміз не?", a: "Бірнеше индексті біріктіріп қолдану" },
                { q: "Materialized view дегеніміз не?", a: "Алдын ала есептелген нәтижелерді сақтау" },
                { q: "Query hint дегеніміз не?", a: "Optimizer-ге нұсқаулар беру" },
                { q: "Statistics дегеніміз не?", a: "Кесте туралы метадата (optimizer үшін)" },
                { q: "Execution plan дегеніміз не?", a: "Сұраныс қалай орындалатынының жоспары" }
            ],
            hard: [
                { q: "Cost-based optimization қалай жұмыс істейді?", a: "Әр жоспардың бағасын есептеп, ең арзанын таңдау" },
                { q: "Adaptive query execution дегеніміз не?", a: "Runtime статистикасы бойынша жоспарды өзгерту" },
                { q: "Index skip scan дегеніміз не?", a: "Composite index-тің бірінші бағанын өткізіп жіберу" },
                { q: "Parallel query execution қалай жұмыс істейді?", a: "Сұранысты бірнеше thread-те орындау" },
                { q: "Histogram statistics дегеніміз не?", a: "Деректер таралуын анықтау (optimizer үшін)" },
                { q: "Join reordering дегеніміз не?", a: "JOIN операцияларын оптимальды ретпен орындау" },
                { q: "Predicate pushdown дегеніміз не?", a: "WHERE шарттарын ерте қолдану" },
                { q: "Columnar storage қашан артықшылықты?", a: "Аналитикалық сұраныстарда (OLAP)" },
                { q: "Query parallelization стратегиялары қандай?", a: "Inter-query, intra-query, intra-operation" },
                { q: "Adaptive indexing дегеніміз не?", a: "Сұраныс patterns-ке қарай автоматты индекс құру" }
            ]
        }
    },
    networks: {
        protocols: {
            easy: [
                { q: "TCP және UDP арасындағы айырмашылық неде?", a: "TCP байланыс орнатады және кепілдік береді, UDP тезірек бірақ кепілсіз" },
                { q: "HTTP дегеніміз не?", a: "HyperText Transfer Protocol - веб-беттерді жіберу протоколы" },
                { q: "HTTPS HTTP-ден қалай ерекшеленеді?", a: "HTTPS шифрланған, SSL/TLS қолданады" },
                { q: "IP адрес дегеніміз не?", a: "Желідегі құрылғының бірегей мекенжайы" },
                { q: "DNS не істейді?", a: "Domain атауларын IP адрестерге аударады" },
                { q: "Port дегеніміз не?", a: "Қосымшаларды ажырату үшін нөмір (0-65535)" },
                { q: "GET және POST әдістері арасындағы айырмашылық неде?", a: "GET деректерді алады, POST жібереді" },
                { q: "MAC адрес дегеніміз не?", a: "Желілік карта hardware адресі" },
                { q: "DHCP не істейді?", a: "Автоматты IP адрестерді береді" },
                { q: "Subnet mask не үшін қолданылады?", a: "Желі және хост бөлігін ажырату үшін" }
            ],
            medium: [
                { q: "OSI моделінің қабаттары қандай?", a: "Physical, Data Link, Network, Transport, Session, Presentation, Application" },
                { q: "TCP three-way handshake қалай жұмыс істейді?", a: "SYN → SYN-ACK → ACK байланыс орнату үшін" },
                { q: "NAT (Network Address Translation) не істейді?", a: "Жергілікті IP-ларды public IP-ға аударады" },
                { q: "Routing protocols қандай?", a: "RIP, OSPF, BGP - маршрутизация хаттамалары" },
                { q: "ARP протоколы не істейді?", a: "IP адресті MAC адреске аударады" },
                { q: "ICMP протоколы не үшін қолданылады?", a: "Ping, traceroute үшін - қателерді хабарлау" },
                { q: "SSL/TLS handshake қалай жұмыс істейді?", a: "Certificate exchange, key agreement, encryption negotiation" },
                { q: "IPv4 және IPv6 арасындағы айырмашылық неде?", a: "IPv4 - 32 бит (4.3 млрд), IPv6 - 128 бит (шексіз)" },
                { q: "VLAN дегеніміз не?", a: "Virtual LAN - виртуальды желі сегменттері" },
                { q: "QoS (Quality of Service) не істейді?", a: "Трафикке приоритет береді" }
            ],
            hard: [
                { q: "BGP routing қалай жұмыс істейді?", a: "AS-тер арасында маршруттарды алмасу, path vector protocol" },
                { q: "TCP congestion control механизмдері қандай?", a: "Slow start, congestion avoidance, fast retransmit, fast recovery" },
                { q: "SDN (Software-Defined Networking) дегеніміз не?", a: "Control plane мен data plane бөлінген, программалық басқару" },
                { q: "MPLS (Multiprotocol Label Switching) қалай жұмыс істейді?", a: "Label-дар бойынша жылдам маршрутизация" },
                { q: "IPsec протоколы қалай жұмыс істейді?", a: "AH және ESP - IP деңгейінде шифрлау" },
                { q: "QUIC протоколы не береді?", a: "UDP үстінде TCP мүмкіндіктері, HTTP/3 үшін" },
                { q: "DDoS қорғаныс механизмдері қандай?", a: "Rate limiting, SYN cookies, traffic scrubbing" },
                { q: "CDN (Content Delivery Network) қалай жұмыс істейді?", a: "Географиялық кэш серверлері, latency азайту" },
                { q: "Load balancing алгоритмдері қандай?", a: "Round-robin, least connections, IP hash, weighted" },
                { q: "WebRTC архитектурасы қандай?", a: "P2P байланыс, STUN/TURN серверлер, NAT traversal" }
            ]
        },
        security: {
            easy: [
                { q: "Firewall не істейді?", a: "Желілік трафикті сүзеді және қорғайды" },
                { q: "VPN дегеніміз не?", a: "Virtual Private Network - қауіпсіз байланыс туннелі" },
                { q: "Шифрлау (encryption) не үшін қолданылады?", a: "Деректерді оқуға болмайтын етіп түрлендіру" },
                { q: "Authentication және authorization арасындағы айырмашылық неде?", a: "Authentication - кім екеніңді тексеру, authorization - не істей алатыныңды тексеру" },
                { q: "Symmetric және asymmetric шифрлау арасындағы айырмашылық неде?", a: "Symmetric - бір кілт, asymmetric - public/private кілттер жұбы" },
                { q: "Hash function дегеніміз не?", a: "Деректерді фиксті өлшемді мәнге түрлендіру" },
                { q: "Salt қашан қолданылады?", a: "Парольдерді хэштеуде қауіпсіздікті арттыру үшін" },
                { q: "SQL injection дегеніміз не?", a: "SQL код injection арқылы шабуыл" },
                { q: "XSS (Cross-Site Scripting) дегеніміз не?", a: "Зиянды JavaScript кодты енгізу шабуылы" },
                { q: "CSRF дегеніміз не?", a: "Cross-Site Request Forgery - өкілеттіліксіз сұраныстар" }
            ],
            medium: [
                { q: "RSA шифрлау алгоритмі қалай жұмыс істейді?", a: "Public/private кілттер, жай сандар факторизациясына негізделген" },
                { q: "Digital certificate дегеніміз не?", a: "Public кілтті растайтын электронды құжат" },
                { q: "PKI (Public Key Infrastructure) қалай жұмыс істейді?", a: "CA (Certificate Authority) сертификаттар береді және басқарады" },
                { q: "Man-in-the-middle attack дегеніміз не?", a: "Екі тарап арасындағы байланысты ұстап алу" },
                { q: "Rainbow table attack қалай жұмыс істейді?", a: "Алдын ала есептелген hash кестелері арқылы" },
                { q: "OAuth 2.0 протоколы не істейді?", a: "Үшінші тарап қосымшаларға қауіпсіз рұқсат беру" },
                { q: "JWT (JSON Web Token) қалай жұмыс істейді?", a: "Stateless authentication, токен құрамында ақпарат бар" },
                { q: "Two-factor authentication қалай жұмыс істейді?", a: "Екі түрлі растау: password + SMS/app" },
                { q: "OWASP Top 10 дегеніміз не?", a: "Ең кең таралған веб-қауіпсіздік проблемалары" },
                { q: "Penetration testing дегеніміз не?", a: "Әлсіздіктерді табу үшін әдейі шабуыл жасау" }
            ],
            hard: [
                { q: "Zero-day exploit дегеніміз не?", a: "Әзірше белгісіз әлсіздікті пайдалану" },
                { q: "Perfect forward secrecy дегеніміз не?", a: "Кілт компромацияланса да, бұрынғы сессиялар қауіпсіз" },
                { q: "Side-channel attack қалай жұмыс істейді?", a: "Физикалық ақпарат (уақыт, қуат) арқылы шабуыл" },
                { q: "Homomorphic encryption дегеніміз не?", a: "Шифрланған деректермен есептеу жасау" },
                { q: "Zero-knowledge proof дегеніміз не?", a: "Ақпаратты ашпай-ақ білетіндігіңді дәлелдеу" },
                { q: "Blockchain қауіпсіздік модельі қалай жұмыс істейді?", a: "Consensus, cryptographic hashing, distributed ledger" },
                { q: "Quantum cryptography дегеніміз не?", a: "Квантты механика принциптерін қолдану" },
                { q: "Secure multi-party computation дегеніміз не?", a: "Бірнеше тарап ақпаратты ашпай-ақ есептеу жасайды" },
                { q: "Timing attack қалай жұмыс істейді?", a: "Операциялардың уақытын талдау арқылы ақпарат алу" },
                { q: "Hardware security module (HSM) дегеніміз не?", a: "Криптографиялық кілттерді сақтау hardware құрылғысы" }
            ]
        },
        architecture: {
            easy: [
                { q: "Client-server архитектурасы дегеніміз не?", a: "Client сұраныс жасайды, server жауап береді" },
                { q: "Peer-to-peer (P2P) дегеніміз не?", a: "Барлық компьютерлер тең құқылы" },
                { q: "LAN дегеніміз не?", a: "Local Area Network - жергілікті желі" },
                { q: "WAN дегеніміз не?", a: "Wide Area Network - кең аумақты желі" },
                { q: "Router не істейді?", a: "Пакеттерді маршрутизациялайды, желілерді байланыстырады" },
                { q: "Switch не істейді?", a: "Құрылғыларды бір желіде байланыстырады" },
                { q: "Hub дегеніміз не?", a: "Барлық портқа деректерді таратады (ескірген)" },
                { q: "Gateway дегеніміз не?", a: "Екі әртүрлі желіні байланыстырады" },
                { q: "Proxy server не істейді?", a: "Аралық сервер, сұраныстарды жібереді" },
                { q: "Load balancer дегеніміз не?", a: "Жүктемені бірнеше серверге таратады" }
            ],
            medium: [
                { q: "Three-tier architecture дегеніміз не?", a: "Presentation, Application, Data layers" },
                { q: "Microservices архитектурасы дегеніміз не?", a: "Қосымшаны кіші, тәуелсіз сервистерге бөлу" },
                { q: "Monolithic vs Microservices - артықшылықтар мен кемшіліктер?", a: "Monolithic қарапайым, Microservices масштабталады" },
                { q: "Service mesh дегеніміз не?", a: "Microservices байланысын басқару инфраструктурасы" },
                { q: "API Gateway дегеніміз не?", a: "Бір кіру нүктесі барлық microservices үшін" },
                { q: "Message queue архитектурасы қалай жұмыс істейді?", a: "Асинхронды хабарламалар жүйесі, decoupling" },
                { q: "Event-driven architecture дегеніміз не?", a: "Оқиғаларға жауап беретін компоненттер" },
                { q: "CQRS дегеніміз не?", a: "Command Query Responsibility Segregation - оқу/жазу бөлу" },
                { q: "Data replication дегеніміз не?", a: "Деректерді бірнеше жерде көшіру" },
                { q: "Caching layer дегеніміз не?", a: "Жиі қолданылатын деректерді жылдам сақтау" }
            ],
            hard: [
                { q: "Distributed systems CAP theorem дегеніміз не?", a: "Consistency, Availability, Partition tolerance - екеуін ғана тандауға болады" },
                { q: "Event sourcing архитектурасы қалай жұмыс істейді?", a: "Барлық өзгерістерді events ретінде сақтау" },
                { q: "Saga pattern distributed transactions-та қалай жұмыс істейді?", a: "Компенсациялау әрекеттері арқылы consistency" },
                { q: "Circuit breaker pattern дегеніміз не?", a: "Қатемен сервисті уақытша өшіру, каскадты қателер болдырмау" },
                { q: "Bulkhead pattern дегеніміз не?", a: "Ресурстарды изоляциялау, қателер таралмас үшін" },
                { q: "Sidecar pattern дегеніміз не?", a: "Көмекші контейнер негізгі қосымшамен бірге" },
                { q: "Strangler fig pattern дегеніміз не?", a: "Ескі жүйені біртіндеп жаңасымен алмастыру" },
                { q: "Blue-green deployment дегеніміз не?", a: "Екі бірдей орта, жылдам қайтару мүмкіндігімен" },
                { q: "Canary deployment дегеніміз не?", a: "Жаңартуды кіші пайдаланушылар тобына алдымен беру" },
                { q: "Chaos engineering дегеніміз не?", a: "Жүйені сынау үшін әдейі қателер енгізу" }
            ]
        }
    },
    webdev: {
        frontend: {
            easy: [
                { q: "HTML дегеніміз не?", a: "HyperText Markup Language - веб-бет құрылымы" },
                { q: "CSS не үшін қолданылады?", a: "Веб-беттің стилін және дизайнын анықтау үшін" },
                { q: "JavaScript не істейді?", a: "Веб-бетке интерактивтілік қосады" },
                { q: "<div> және <span> арасындағы айырмашылық неде?", a: "div - блокты элемент, span - inline элемент" },
                { q: "id және class атрибуттары арасындағы айырмашылық неде?", a: "id - бірегей, class - бірнеше элементке" },
                { q: "DOM дегеніміз не?", a: "Document Object Model - HTML құжат құрылымы" },
                { q: "Event listener не істейді?", a: "Оқиғаларды (click, hover) тыңдап, әрекет жасайды" },
                { q: "Responsive design дегеніміз не?", a: "Әртүрлі экран өлшемдеріне бейімделетін дизайн" },
                { q: "localStorage және sessionStorage арасындағы айырмашылық неде?", a: "localStorage тұрақты, sessionStorage сессия ішінде ғана" },
                { q: "AJAX дегеніміз не?", a: "Асинхронды сервермен байланыс, бетті қайта жүктемей" }
            ],
            medium: [
                { q: "Flexbox қалай жұмыс істейді?", a: "Элементтерді икемді орналастыру, justify-content, align-items" },
                { q: "CSS Grid дегеніміз не?", a: "Екі өлшемді layout жүйесі" },
                { q: "Event bubbling және capturing дегеніміз не?", a: "Bubbling - төменнен жоғары, capturing - жоғарыдан төмен" },
                { q: "Closure JavaScript-те қалай жұмыс істейді?", a: "Функция өзінің scope-ын есте сақтайды" },
                { q: "Promise және async/await арасындағы айырмашылық неде?", a: "async/await - Promise-ты оқуға оңай синтаксис" },
                { q: "Virtual DOM дегеніміз не?", a: "DOM-ның жады көшірмесі, React-та қолданылады" },
                { q: "Component lifecycle methods React-та қандай?", a: "componentDidMount, componentDidUpdate, componentWillUnmount" },
                { q: "State management дегеніміз не?", a: "Қосымша деректерін басқару (Redux, Context)" },
                { q: "Webpack не істейді?", a: "Module bundler - файлдарды біріктіреді және оптимизациялайды" },
                { q: "Progressive Web App дегеніміз не?", a: "Offline жұмыс істейтін, орнатылатын веб-қосымша" }
            ],
            hard: [
                { q: "React Fiber архитектурасы қалай жұмыс істейді?", a: "Incremental rendering, prioritization, scheduling" },
                { q: "Virtual DOM diffing алгоритмі қалай жұмыс істейді?", a: "Reconciliation - өзгерістерді табу және минималды жаңарту" },
                { q: "Server-side rendering және client-side rendering арасындағы trade-off-тар қандай?", a: "SSR - SEO жақсы, CSR - интерактивті" },
                { q: "Code splitting және lazy loading қалай жұмыс істейді?", a: "Dynamic import(), қажет кезде жүктеу" },
                { q: "Web workers қалай жұмыс істейді?", a: "Background thread-терде код орындау" },
                { q: "Service workers және PWA кэштеу стратегиялары қандай?", a: "Cache first, network first, stale-while-revalidate" },
                { q: "WebAssembly дегеніміз не?", a: "Binary instruction format, жоғары өнімділік үшін" },
                { q: "Micro-frontends архитектурасы қалай жұмыс істейді?", a: "Frontend-ты тәуелсіз бөліктерге бөлу" },
                { q: "GraphQL және REST арасындағы trade-off-тар қандай?", a: "GraphQL - икемді, over/under-fetching жоқ" },
                { q: "Server components React-та қалай жұмыс істейді?", a: "Серверде render, client JavaScript азайту" }
            ]
        },
        backend: {
            easy: [
                { q: "REST API дегеніміз не?", a: "HTTP әдістерін қолданатын веб-сервис" },
                { q: "GET, POST, PUT, DELETE әдістері не істейді?", a: "Оқу, жасау, жаңарту, өшіру" },
                { q: "HTTP status codes не үшін?", a: "Сұраныс нәтижесін көрсету: 200 OK, 404 Not Found" },
                { q: "JSON дегеніміз не?", a: "JavaScript Object Notation - деректер форматы" },
                { q: "API endpoint дегеніміз не?", a: "API-ға қатынау URL мекенжайы" },
                { q: "Middleware дегеніміз не?", a: "Сұранысты өңдеу арасындағы функциялар" },
                { q: "Session және token authentication арасындағы айырмашылық неде?", a: "Session серверде сақталады, token клиентте" },
                { q: "CORS дегеніміз не?", a: "Cross-Origin Resource Sharing - басқа доменнен сұраныс" },
                { q: "Environment variables не үшін қолданылады?", a: "Конфигурация параметрлерін сақтау" },
                { q: "API documentation не үшін керек?", a: "API қолдануды түсіндіру (Swagger, OpenAPI)" }
            ],
            medium: [
                { q: "Microservices архитектурасы дегеніміз не?", a: "Қосымшаны кіші, тәуелсіз сервистерге бөлу" },
                { q: "Message queue дегеніміз не?", a: "Асинхронды хабарламалар жүйесі (RabbitMQ, Kafka)" },
                { q: "Caching стратегиялары қандай?", a: "Cache-aside, write-through, write-behind" },
                { q: "Rate limiting қалай жұмыс істейді?", a: "Сұраныс санын шектеу, DDoS қорғаныс" },
                { q: "Database connection pooling дегеніміз не?", a: "Байланыстарды қайта пайдалану, өнімділік" },
                { q: "ORM (Object-Relational Mapping) дегеніміз не?", a: "Деректер қорын объекттер арқылы басқару" },
                { q: "GraphQL schema дегеніміз не?", a: "API типтері мен өрістерінің анықтамасы" },
                { q: "Webhook дегеніміз не?", a: "Event-driven HTTP callback" },
                { q: "API versioning қалай жүзеге асырылады?", a: "URL-де, header-де немесе параметрде версия көрсету" },
                { q: "Circuit breaker pattern дегеніміз не?", a: "Қатемен сервисті уақытша өшіру" }
            ],
            hard: [
                { q: "Event sourcing дегеніміз не?", a: "Барлық өзгерістерді event-тер ретінде сақтау" },
                { q: "CQRS (Command Query Responsibility Segregation) дегеніміз не?", a: "Оқу және жазу операцияларын бөлу" },
                { q: "Saga pattern distributed transactions-та қалай жұмыс істейді?", a: "Компенсациялау әрекеттері арқылы consistency" },
                { q: "Service mesh дегеніміз не?", a: "Microservices байланысын басқару (Istio)" },
                { q: "API Gateway pattern қалай жұмыс істейді?", a: "Бір кіру нүктесі, routing, authentication" },
                { q: "Backend for Frontend (BFF) дегеніміз не?", a: "Әрбір frontend үшін арнайы backend" },
                { q: "Distributed tracing қалай жұмыс істейді?", a: "Microservices арқылы сұранысты бақылау" },
                { q: "Zero-downtime deployment стратегиялары қандай?", a: "Blue-green, canary, rolling deployment" },
                { q: "Backpressure handling дегеніміз не?", a: "Жүктемені басқару, producer-ды баяулату" },
                { q: "Distributed caching стратегиялары қандай?", a: "Consistent hashing, cache invalidation" }
            ]
        },
        fullstack: {
            easy: [
                { q: "Full-stack developer дегеніміз кім?", a: "Frontend және backend екеуін де білетін әзірлеуші" },
                { q: "CRUD операциялары дегеніміз не?", a: "Create, Read, Update, Delete" },
                { q: "MVC архитектурасы дегеніміз не?", a: "Model, View, Controller - үш қабат" },
                { q: "SPA (Single Page Application) дегеніміз не?", a: "Бір бетте жұмыс істейтін қосымша" },
                { q: "SSR (Server-Side Rendering) дегеніміз не?", a: "HTML серверде генерациялау" },
                { q: "CSR (Client-Side Rendering) дегеніміз не?", a: "HTML браузерде JavaScript арқылы құру" },
                { q: "JWT токен құрылымы қандай?", a: "Header, Payload, Signature" },
                { q: "Cookie және session арасындағы айырмашылық неде?", a: "Cookie клиентте, session серверде" },
                { q: "HTTPS-тың HTTP-ден айырмашылығы неде?", a: "HTTPS шифрланған, SSL/TLS қолданады" },
                { q: "Deployment дегеніміз не?", a: "Қосымшаны production серверге орналастыру" }
            ],
            medium: [
                { q: "Authentication vs Authorization", a: "Authentication - кім екеніңді тексеру, Authorization - не істей алатыныңды тексеру" },
                { q: "OAuth 2.0 flow қалай жұмыс істейді?", a: "Authorization code, implicit, client credentials, password grants" },
                { q: "WebSocket дегеніміз не?", a: "Екі бағытты real-time байланыс" },
                { q: "Server-sent events (SSE) дегеніміз не?", a: "Серверден клиентке бір бағытты push" },
                { q: "GraphQL subscription қалай жұмыс істейді?", a: "Real-time деректер алу WebSocket арқылы" },
                { q: "Monorepo vs Polyrepo", a: "Monorepo - барлық код бір репозиторийде, Polyrepo - әрқайсысы бөлек" },
                { q: "CI/CD дегеніміз не?", a: "Continuous Integration/Deployment - автоматты тестілеу және deploy" },
                { q: "Docker контейнері дегеніміз не?", a: "Оқшауланған орта қосымшаны жүргізу үшін" },
                { q: "Kubernetes не істейді?", a: "Контейнерлерді оркестрациялау және басқару" },
                { q: "Reverse proxy дегеніміз не?", a: "Сервер алдында тұратын аралық сервер (nginx)" }
            ],
            hard: [
                { q: "Jamstack архитектурасы дегеніміз не?", a: "JavaScript, APIs, Markup - статикалық сайттар + API" },
                { q: "Incremental Static Regeneration (ISR) қалай жұмыс істейді?", a: "Статикалық беттерді фонда жаңарту (Next.js)" },
                { q: "Edge computing дегеніміз не?", a: "CDN-де код орындау, пайдаланушыға жақын" },
                { q: "Serverless архитектурасы дегеніміз не?", a: "Серверсіз функциялар, scaling автоматты (AWS Lambda)" },
                { q: "Multi-tenancy архитектурасы қалай жұмыс істейді?", a: "Бір қосымша көп клиентке қызмет етеді" },
                { q: "Distributed transactions қалай басқарылады?", a: "Two-phase commit, Saga pattern" },
                { q: "CQRS + Event Sourcing архитектурасы дегеніміз не?", a: "Команда/сұраныс бөлу + оқиғаларды сақтау" },
                { q: "Hexagonal (Ports and Adapters) architecture дегеніміз не?", a: "Business логика core-да, external-дан оқшауланған" },
                { q: "Strangler pattern дегеніміз не?", a: "Legacy жүйені біртіндеп жаңасымен алмастыру" },
                { q: "Feature flags қалай жүзеге асырылады?", a: "Runtime кезінде функцияларды қосу/өшіру" }
            ]
        }
    }
};

// Critical Thinking Questions - AI Answers with Errors
const criticalThinkingDB = {
    algorithms: [
        {
            question: "Binary search алгоритмі қалай жұмыс істейді және оның уақыттық күрделілігі қандай?",
            aiAnswer: "Binary search - бұл массивтен элемент іздеу алгоритмі. Ол массивті екіге бөледі және іздейтін элементпен ортаңғы элементті салыстырады. Егер тең болса, іздеу аяқталады. Егер іздейтін элемент кіші болса, оң жаққа қарайды, үлкен болса сол жаққа қарайды. Бұл процесс элемент табылғанша қайталанады. Уақыттық күрделілігі O(n) болып табылады, өйткені әрбір қадамда массив өлшемі екіге кемиді.",
            errors: [
                {
                    text: "Binary search кез келген массивте жұмыс істей ма?",
                    correct: false,
                    explanation: "Жоқ! Binary search тек СҰРЫПТАЛҒАН массивтерде ғана жұмыс істейді. Бұл өте маңызды шарт."
                },
                {
                    text: "Уақыттық күрделілік O(n) дұрыс па?",
                    correct: false,
                    explanation: "Жоқ! Binary search-тың уақыттық күрделілігі O(log n), O(n) емес. Бұл негізгі артықшылығы."
                },
                {
                    text: "Іздеу бағыты дұрыс көрсетілген бе?",
                    correct: false,
                    explanation: "Жоқ! Егер іздейтін элемент кіші болса, СОЛ жаққа қарау керек, оң жаққа емес."
                }
            ],
            hint: "Binary search-тың негізгі шарттарын және Big O нотациясын еске түсіріңіз"
        },
        {
            question: "Quick sort алгоритмі қалай жұмыс істейді және оның артықшылықтары мен кемшіліктері қандай?",
            aiAnswer: "Quick sort - бұл әрқашан тұрақты O(n log n) күрделілігі бар сұрыптау алгоритмі. Ол pivot элементін таңдайды (әрқашан соңғы элемент) және массивті екіге бөледі: pivot-тан кіші элементтер сол жағында, үлкен элементтер оң жағында. Содан кейін рекурсивті түрде әрбір бөлікті сұрыптайды. Quick sort stable sorting algorithm болып табылады, яғни тең элементтердің реті сақталады. Сондай-ақ ол in-place алгоритм болғандықтан қосымша жады қажет етпейді.",
            aiAnswer: "Quick sort - бұл әрқашан тұрақты O(n log n) күрделілігі бар сұрыптау алгоритмі. Ол pivot элементін таңдайды (әрқашан соңғы элемент) және массивті екіге бөледі: pivot-тан кіші элементтер сол жағында, үлкен элементтер оң жағында. Содан кейін рекурсивті түрде әрбір бөлікті сұрыптайды. Quick sort stable sorting algorithm болып табылады, яғни тең элементтердің реті сақталады. Сондай-ақ ол in-place алгоритм болғандықтан қосымша жады қажет етпейді.",
            errors: [
                {
                    text: "Уақыттық күрделілік әрқашан O(n log n) ма?",
                    correct: false,
                    explanation: "Жоқ! Worst case-де (нашар pivot таңдалса) Quick sort O(n²) күрделілікке ие болуы мүмкін."
                },
                {
                    text: "Pivot әрқашан соңғы элемент бола ма?",
                    correct: false,
                    explanation: "Жоқ! Pivot таңдау стратегиясы әртүрлі болуы мүмкін: соңғы, бірінші, ортаңғы, кездейсоқ, median-of-three."
                },
                {
                    text: "Quick sort stable algorithm ма?",
                    correct: false,
                    explanation: "Жоқ! Quick sort UNSTABLE алгоритм. Тең элементтердің реті өзгеруі мүмкін."
                }
            ],
            hint: "Worst case сценарийлерді және stable/unstable sorting ұғымын ойлаңыз"
        },
        {
            question: "Hash table-дағы collision дегеніміз не және оны қалай шешуге болады?",
            aiAnswer: "Hash table-да collision болмайды, өйткені hash функция әрқашан бірегей мәндер қайтарады. Әрбір элементке өзінің уникалды hash мәні тағайындалады, сондықтан екі әртүрлі кілт ешқашан бірдей hash мәніне ие бола алмайды. Hash table-дың уақыттық күрделілігі әрқашан O(1) болып табылады, өйткені collision мүлдем болмайды. Hash function дұрыс жазылса, ешқандай проблема туындамайды.",
            errors: [
                {
                    text: "Collision мүлдем болмайды ма?",
                    correct: false,
                    explanation: "Жоқ! Collision өте жиі кездеседі. Екі әртүрлі кілт бірдей hash мәніне ие болуы мүмкін."
                },
                {
                    text: "Уақыттық күрделілік әрқашан O(1) ма?",
                    correct: false,
                    explanation: "Жоқ! Collision көп болса, worst case O(n) болуы мүмкін."
                },
                {
                    text: "Collision шешу әдістері қажет емес пе?",
                    correct: false,
                    explanation: "Жоқ! Chaining, open addressing сияқты әдістер қажет."
                }
            ],
            hint: "Pigeonhole principle туралы ойланыңыз - элементтер көп, bucket-тер шектеулі"
        }
    ],
    programming: [
        {
            question: "Python-дағы list және tuple арасындағы негізгі айырмашылықтар қандай?",
            aiAnswer: "List және tuple Python-да бірдей, тек синтаксисі басқа. List квадрат жақшаларда [1,2,3], tuple жөн жақшаларда (1,2,3) жазылады. Екеуі де өзгертілетін (mutable) және бірдей әдістерге ие: append(), remove(), pop() және т.б. Олардың арасында ешқандай өнімділік айырмашылығы жоқ, сондықтан қайсысын қолданғаныңыз маңызды емес. Tuple мен list кез келген жағдайда алмастырып қолдануға болады.",
            errors: [
                {
                    text: "Tuple өзгертілетін (mutable) ма?",
                    correct: false,
                    explanation: "Жоқ! Tuple IMMUTABLE, оны өзгерту мүмкін емес. Бұл негізгі айырмашылық."
                },
                {
                    text: "Бірдей әдістер бар ма?",
                    correct: false,
                    explanation: "Жоқ! Tuple-де append(), remove(), pop() жоқ, өйткені ол өзгермейді."
                },
                {
                    text: "Өнімділік айырмашылығы жоқ па?",
                    correct: false,
                    explanation: "Жоқ! Tuple жылдамырақ және жады азырақ алады, өйткені өзгермейді."
                }
            ],
            hint: "Mutable vs Immutable концепциясын еске түсіріңіз"
        },
        {
            question: "Декораторлар Python-да қалай жұмыс істейді?",
            aiAnswer: "Декоратор - бұл функцияға қосымша код қосатын арнайы Python синтаксис. @ символынан кейін декоратор атауы жазылады. Декораторлар тек функциялармен жұмыс істей алады, класстармен жұмыс істемейді. Декоратор өзгертілетін функцияны тікелей өзгертеді, сондықтан орналған функция жоғалады. Бір функцияға тек бір декоратор ғана қолдануға болады.",
            errors: [
                {
                    text: "Декораторлар тек функцияларға қолданылады ма?",
                    correct: false,
                    explanation: "Жоқ! Декораторларды класстарға да қолдануға болады."
                },
                {
                    text: "Орналған функция жоғалады ма?",
                    correct: false,
                    explanation: "Жоқ! Декоратор wrapper функция қайтарады, орналған функция сақталады."
                },
                {
                    text: "Тек бір декоратор қолдануға бола ма?",
                    correct: false,
                    explanation: "Жоқ! Бірнеше декораторларды тізбектей қолдануға болады."
                }
            ],
            hint: "Декоратор дегеніміз higher-order function екенін есте сақтаңыз"
        }
    ],
    databases: [
        {
            question: "SQL-дегі INNER JOIN және LEFT JOIN арасындағы айырмашылық неде?",
            aiAnswer: "INNER JOIN және LEFT JOIN бірдей нәтиже береді. Екеуі де екі кестенің барлық жолдарын қайтарады. Айырмашылығы тек синтаксисте: INNER JOIN аз код, LEFT JOIN көбірек код жазуды талап етеді. Өнімділігі де бірдей, сондықтан кодыңызда қайсысын қолданғаныңыз маңызды емес. SQL optimizer екеуін де бірдей орындайды.",
            errors: [
                {
                    text: "Бірдей нәтиже береді ме?",
                    correct: false,
                    explanation: "Жоқ! INNER JOIN - тек сәйкестік бар жолдар, LEFT JOIN - сол кестенің барлық жолдары."
                },
                {
                    text: "Барлық жолдарды қайтарады ма?",
                    correct: false,
                    explanation: "Жоқ! INNER JOIN - тек екі кестеде де бар жолдарды қайтарады."
                },
                {
                    text: "Өнімділік бірдей ме?",
                    correct: false,
                    explanation: "Жоқ! LEFT JOIN баяулау болуы мүмкін, өйткені көбірек жолдарды өңдейді."
                }
            ],
            hint: "JOIN операциялары қандай жолдарды қайтаратынын визуалдаңыз"
        },
        {
            question: "Database normalization дегеніміз не және не үшін қажет?",
            aiAnswer: "Normalization - бұл деректерді кестелерге бөлу процесі. Ол қажет емес, өйткені қазіргі деректер қорлары өте жылдам және жады көп. Бір үлкен кестеде барлық деректерді сақтау жеңілірек және тезірек. Normalization тек ескі деректер қорларында қолданылды. Қазіргі заманғы қосымшаларда denormalization (барлық деректерді бір кестеде сақтау) ұсынылады.",
            errors: [
                {
                    text: "Normalization қажет емес пе?",
                    correct: false,
                    explanation: "Жоқ! Normalization маңызды: қайталауды азайтады, integrity қамтамасыз етеді."
                },
                {
                    text: "Бір үлкен кесте жақсырақ па?",
                    correct: false,
                    explanation: "Жоқ! Redundancy, anomalies, update проблемалары пайда болады."
                },
                {
                    text: "Тек ескі ДҚ-да қолданылады ма?",
                    correct: false,
                    explanation: "Жоқ! Normalization әлі де best practice, әсіресе transactional жүйелерде."
                }
            ],
            hint: "Data redundancy және anomalies проблемаларын ойлаңыз"
        }
    ],
    security: [
        {
            question: "Password хэштеуде salt не үшін қолданылады?",
            aiAnswer: "Salt - бұл парольге қосылатын кездейсоқ мәтін. Әрбір пайдаланушыға бірдей salt қолданылады, мысалы 'mysecret123'. Salt құпия сақталуы керек және ешкімге көрсетілмеуі тиіс. Salt database-те сақталмайды, тек код ішінде қолданылады. Salt қолданғанда парольді қайтадан хэштемей-ақ тексеруге болады.",
            errors: [
                {
                    text: "Әрбір пайдаланушыға бірдей salt ма?",
                    correct: false,
                    explanation: "Жоқ! Әрбір пайдаланушыға ӘРТҮРЛІ, кездейсоқ salt керек."
                },
                {
                    text: "Salt құпия ма?",
                    correct: false,
                    explanation: "Жоқ! Salt құпия емес, database-те hash-пен бірге сақталады."
                },
                {
                    text: "Salt database-те сақталмайды ма?",
                    correct: false,
                    explanation: "Жоқ! Salt міндетті түрде database-те hash-пен бірге сақталуы керек."
                }
            ],
            hint: "Rainbow table шабуылдарынан қалай қорғануды ойлаңыз"
        }
    ]
};

// Achievements Database
const achievementsDB = [
    {
        id: 'first_try',
        icon: '🎯',
        title: 'Алғашқы әрекет',
        description: 'Бірінші тапсырманы орындадыңыз',
        unlocked: false,
        progress: 0,
        maxProgress: 1,
        condition: (stats) => stats.attempts >= 1
    },
    {
        id: 'independent',
        icon: '🦅',
        title: 'Тәуелсіз',
        description: 'Кеңес алмай-ақ 5 тапсырманы дұрыс шештіңіз',
        unlocked: false,
        progress: 0,
        maxProgress: 5,
        condition: (stats) => stats.solvedWithoutHints >= 5
    },
    {
        id: 'perfectionist',
        icon: '⭐',
        title: 'Перфекционист',
        description: 'Бір әрекеттен 10 тапсырманы дұрыс шештіңіз',
        unlocked: false,
        progress: 0,
        maxProgress: 10,
        condition: (stats) => stats.firstTryCorrect >= 10
    },
    {
        id: 'critical_thinker',
        icon: '🧠',
        title: 'Сыни ойлаушы',
        description: 'AI жауабындағы 10 қатені таптыңыз',
        unlocked: false,
        progress: 0,
        maxProgress: 10,
        condition: (stats) => stats.errorsFound >= 10
    },
    {
        id: 'ai_skeptic',
        icon: '🔍',
        title: 'AI скептик',
        description: 'Барлық AI қателерін дұрыс анықтадыңыз',
        unlocked: false,
        progress: 0,
        maxProgress: 5,
        condition: (stats) => stats.perfectCriticalAnalysis >= 5
    },
    {
        id: 'learner',
        icon: '📚',
        title: 'Үздік оқушы',
        description: '50 тапсырманы аяқтадыңыз',
        unlocked: false,
        progress: 0,
        maxProgress: 50,
        condition: (stats) => stats.correctAnswers >= 50
    },
    {
        id: 'low_dependency',
        icon: '💪',
        title: 'AI-дан тәуелсіз',
        description: 'Тәуелділік индексін 20% төмен ұстадыңыз',
        unlocked: false,
        progress: 0,
        maxProgress: 1,
        condition: (stats) => stats.currentDependency <= 20 && stats.attempts >= 10
    },
    {
        id: 'streak_5',
        icon: '🔥',
        title: '5 қатар',
        description: '5 тапсырманы қатарынан дұрыс шештіңіз',
        unlocked: false,
        progress: 0,
        maxProgress: 5,
        condition: (stats) => stats.currentStreak >= 5
    },
    {
        id: 'streak_10',
        icon: '🌟',
        title: '10 қатар',
        description: '10 тапсырманы қатарынан дұрыс шештіңіз',
        unlocked: false,
        progress: 0,
        maxProgress: 10,
        condition: (stats) => stats.currentStreak >= 10
    },
    {
        id: 'polymath',
        icon: '🎓',
        title: 'Полимат',
        description: 'Барлық пәндерден тапсырма орындадыңыз',
        unlocked: false,
        progress: 0,
        maxProgress: 5,
        condition: (stats) => stats.subjectsCompleted >= 5
    },
    {
        id: 'master',
        icon: '👑',
        title: 'Шебер',
        description: '90%+ сәттілік көрсеткішімен 30 тапсырма',
        unlocked: false,
        progress: 0,
        maxProgress: 30,
        condition: (stats) => stats.correctAnswers >= 30 && (stats.correctAnswers / stats.attempts) >= 0.9
    },
    {
        id: 'helper_avoider',
        icon: '🚫',
        title: 'Көмексіз',
        description: '20 тапсырманы кеңес алмай шештіңіз',
        unlocked: false,
        progress: 0,
        maxProgress: 20,
        condition: (stats) => stats.solvedWithoutHints >= 20
    }
];

// Skills Database
const skillsDB = [
    {
        id: 'critical_thinking',
        name: 'Сыни ойлау',
        icon: '🧠',
        level: 0,
        xp: 0,
        maxXP: 100,
        description: 'AI жауаптарын талдау және бағалау қабілеті'
    },
    {
        id: 'problem_solving',
        name: 'Проблеманы шешу',
        icon: '🔧',
        level: 0,
        xp: 0,
        maxXP: 100,
        description: 'Тапсырмаларды өз бетінше шешу дағдысы'
    },
    {
        id: 'independence',
        name: 'Тәуелсіздік',
        icon: '🦅',
        level: 0,
        xp: 0,
        maxXP: 100,
        description: 'AI көмегінсіз жұмыс істей алу'
    },
    {
        id: 'persistence',
        name: 'Табандылық',
        icon: '💪',
        level: 0,
        xp: 0,
        maxXP: 100,
        description: 'Қиын тапсырмаларды ұзақ уақыт шешу'
    },
    {
        id: 'accuracy',
        name: 'Дәлдік',
        icon: '🎯',
        level: 0,
        xp: 0,
        maxXP: 100,
        description: 'Дұрыс жауаптар беру жиілігі'
    }
];

// Topics data
const topicsData = {
    programming: [
        { value: 'variables', text: 'Айнымалылар және деректер түрлері' },
        { value: 'loops', text: 'Циклдар және итерация' },
        { value: 'functions', text: 'Функциялар және модульдер' }
    ],
    algorithms: [
        { value: 'sorting', text: 'Сұрыптау алгоритмдері' },
        { value: 'search', text: 'Іздеу алгоритмдері' },
        { value: 'graphs', text: 'Графтар және ағаштар' }
    ],
    databases: [
        { value: 'sql', text: 'SQL және реляциялық деректер қоры' },
        { value: 'nosql', text: 'NoSQL деректер қоры' },
        { value: 'optimization', text: 'Оптимизация және индекстер' }
    ],
    networks: [
        { value: 'protocols', text: 'Желі протоколдары' },
        { value: 'security', text: 'Желі қауіпсіздігі' },
        { value: 'architecture', text: 'Желі архитектурасы' }
    ],
    webdev: [
        { value: 'frontend', text: 'Frontend әзірлеу' },
        { value: 'backend', text: 'Backend әзірлеу' },
        { value: 'fullstack', text: 'Full-stack интеграция' }
    ]
};
